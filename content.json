{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/08/hello-world/"},{"title":"ggplot2 基础理论知识","text":"主要内容参考bbsmax ggplot2入门与进阶，总体概括ggplot画图思想 ggplot2的核心理念是将绘图与数据分离，数据相关的绘图与数据无关的绘图分离 ggplot2是按图层作图 ggplot2保有命令式作图的调整函数，使其更具灵活性 ggplot2将常见的统计变换融入到了绘图中。 ggplot的绘图有以下几个特点： 第一，有明确的起始（以ggplot函数开始）与终止（一句语句一幅图）； 其二，图层之间的叠加是靠“+”号实现的，越后面其图层越高。 ggplot图的元素主要可以概括如下：最大的是plot（指整张图，包括background和title），其次是axis（包括stick，text，title和stick）、legend（包括backgroud、text、title）、facet这是第二层次，其中facet可以分为外部strip部分（包括backgroud和text）和内部panel部分（包括backgroud、boder和网格线grid，其中粗的叫grid.major，细的叫grid.minor） ggplot2里的所有函数可以分为以下几类： 用于运算（我们在此不讲，如fortify_，mean_等） 初始化、展示绘图等命令（ggplot，plot，print等） 按变量组图（facet_等） 真正的绘图命令（stat_，geom_，annotate），这三类就是实现一个函数一个图层的核心函数 微调图型：严格意义上说，这一类函数不是再实现图层，而是在做局部调整。 aes : 同样适用于修改geom_XXX() aes参数控制了对哪些变量进行图形映射，以及映射方式 图形属性（aes） 横纵坐标、点的大小、颜色，填充色等 123456789# 完整公式总结ggplot(data = , aes(x = , y = )) + geom_XXX(...) + ... + stat_XXX(...) + ... + annotate(...) + ... + labs(...) + scale_XXX(...) + coord_XXX(...) + guides(...) + theme(...) + facet_XXX(...)# 例子library(ggplot2)attach(iris)p &lt;- ggplot(data=iris,aes(x = Sepal.Length,y = Sepal.Width))p + geom_point(aes(colour = Species)) + stat_smooth() + labs(title = \"Iris of Sepal.length \\n According to the Sepal.Width\") +theme_classic() + theme_bw() +annotate(\"text\",x=7,y=4,parse = T,label = \"x[1]==x[2]\",size=6, family=\"serif\",fontface=\"italic\", colour=\"darkred\") 一张统计图形就是从数据到几何对象*(geometric object, 缩写为geom, 包括点、线、条形等)**的图形属性(aesthetic attributes,缩写为aes, 包括颜色、形状、大小等)的一个映射。此外, 图形中还可能包含数据的统计变换(statistical transformation, 缩写为stats), 最后绘制在某个特定的坐标系(coordinate system, 缩写为coord)**中, 而分面(facet, *指将绘图窗口划分为若干个子窗口)**则可以用来生成数据中不同子集的图形。 数据(data) 映射(mapping) ： aes() 几何对象(geom) 标度(scale) : 将数据的取值映射到图形空间，如用颜色，大小，或形状表示不同的取值，常见做法是绘制图例和坐标轴，它们实际上是从图形到数据的映射 统计变换(stats) 坐标系(coord) 分面(facet) 主题(theme) 存储与输出 1.数据 数据必须为数据框，易于使用transform() %+% 转换 ggplot2 数据分组必须根据行，而不是列，要求把宽数据转换为长数据 2.映射 aes(x= , y= ,color=) 映射与设定的区别，映射是将一个变量中离散或连续的数据与一个图形属性中以不同的参数来相互关联, 而设定能够将这个变量中所有的数据统一为一个图形属性 如 geom_point(color=&quot;blue&quot;) group()：分组 12345p1 &lt;- ggplot(data = mtcars, mapping = aes(x = wt, y = hp)) + geom_line()#默认分组设置, 即group=1#geom_line为折线图的几何对象p2 &lt;- ggplot(data = mtcars, mapping = aes(x = wt, y = hp, group = factor(gear))) + geom_line()#把wt和hp所对应的观测点按gear(gear以因子化变为离散变量)进行分组 图层中修改映射 12345678910p &lt;- ggplot(mtcars, aes(x = mpg, y = wt, color = factor(gear)))#设定默认的映射关系p + geom_point()#沿用默认的映射关系来绘制散点图p + geom_point(aes(shape = factor(carb)))#添加图层中的shape的映射关系p + geom_point(aes(y = carb)))#修改默认的y的映射关系, 注意图中y轴名称仍然以默认的wt表示p + geom_point(aes(color = NULL)) #删除默认的color映射关系 图层叠加 1234567mtcars.c &lt;- transform(mtcars, mpg = mpg^2)#构建不同于mtcars的数据集mtcars.c#选用向量数据ggplot()+ geom_point(aes(x = hp, y = mpg), data = mtcars, color = &quot;red&quot;) + geom_point(aes(x = mtcars$hp, y = mtcars$disp), color = &quot;green&quot;)+ geom_point(aes(x = hp, y= mpg), data = mtcars.c, color = &quot;blue&quot;) #选用不同的数据集 3.几何对象几何对象执行着图层的实际渲染, 控制着生成的图像类型 geom_point()，geom_line()，geom_histogram()，geom_density()，geom_boxplot()，geom_text()/label()，geom_violin() 12345678910111213141516p &lt;- ggplot(mtcars, aes(wt, mpg))p + geom_point()#更改颜色-连续变量p + geom_point(aes(color = qsec))#更改颜色-离散变量p + geom_point(aes(color = factor(gear)))#更改透明度p + geom_point(aes(alpha = qsec))#更改形状p + geom_point(aes(shape = factor(gear)))#更改点大小p + geom_point(aes(size = qsec))#两种颜色的叠加p + geom_point(color = \"grey50\", size = 5) + geom_point(aes(color = qsec), size = 4)#颜色和形状的叠加p + geom_point(color = \"grey50\", size = 5) + geom_point(aes(shape = factor(gear)), size = 3) 4.统计变换geom_histogram()**这个几何对象默认使用stat_bin这个统计变换, 将一维的数据分组，变成二维的，从而在xy坐标轴上画图。而这个统计变换会生成(1)count：每个组里观测值的数目, **(2)density：每个组里观测值的密度和(3)x：组的中心位置这三个变量。 1234567m &lt;- ggplot(movies, aes(rating)) #这里使用movies数据集m + geom_histogram()m + geom_histogram(bin = 0.5)#调整分箱(bin)数据m + geom_histogram(bin = 1)m + geom_histogram(bin = 2) 5.元素位置的调整dodeg fill stack jitter 12345678910111213141516d &lt;- ggplot(diamonds, aes(x = clarity, fill = cut )) + geom_histogram(stat=\"count\")# 这里只设定了x的数据映射源，而没有指定y数据映射，而 stat=\"count\"就默认设定了y的数据来源为 总数 ，position默认为 stackd + geom_histogram(stat=\"count\", position = \"dodge\")# dodge：并排方式d + geom_histogram(stat=\"count\",position = \"fill\")# fill : 堆叠，高度标准化为1d + geom_histogram(stat=\"count\",position = \"stack\")# stack : 堆叠图像元素ggplot(diamonds) + geom_point(aes(color, price/carat), position = \"jitter\")# jitter：给点增加扰动避免重合 ，每一个点在x轴的方向上产生随机的偏移, 从而减少了图形重叠的问题# identity： 不做任何调整A &lt;- c(1, 2, 3, 4, 5, 6, 7, 8)B &lt;- c(2, 10, 11, 5, 6, 1, 10, 20)ggplot() + geom_histogram(aes(x = A, y = B), stat = \"identity\")# 声明stat=\"identity\"固定Xy轴作图，不做统计变换，从这里也可以看到，其实画图可以在geom_histogram()中画，ggplot()搭个框架 6.平滑曲线geom_smooth()给数据添加平滑曲线, 所能采用的方法包括了lm, glm, gam, loess, rlm等, 这些方法需要通过加载公式来实现。 1234567891011121314151617m &lt;- ggplot(mtcars, aes(qsec, wt))m + stat_smooth() + geom_point()m + stat_smooth(se = FALSE) + geom_point() #取消默认的置信区间m + stat_smooth(fill = \"red\", size = 2, alpha = 0.5, color = \"green\") + geom_point()#更改置信区间和线条颜色m + stat_smooth(method = \"lm\") + geom_point()#用一元一次线性方程拟合m + stat_smooth(method = \"lm\", formula = y ~ poly(x, 3)) + geom_point()#使用一元二次方程拟合require(splines)require(MASS)m + stat_smooth(method = \"lm\", formula = y ~ ns(x, 3)) + geom_point()# 加载splines和MASS包, 使用自由度为3的自然样条来进行拟合m &lt;- ggplot(mtcars, aes(y = wt, x = mpg, group = factor(cyl)))m + stat_smooth(method = lm, aes(color = factor(cyl), fill = factor(cyl))) + geom_point( aes(color = factor(cyl)))#按cyl这个离散变量进行分组, 分别拟合数据 7.标度 标度控制着数据到图形属性的映射, 更重要的一点是标度将我们的数据转化为视觉上可以感知的东西, 如大小(size)、颜色(color,fill)、位置(position(x,y))、形状(shape)和线条类型(line type)。所以通过标度可以修改坐标轴和图例的参数。 所有标度构建器(scale constructor)**都拥有一套通用的命名方案。它们以scale_开头, 接下来是图形属性的名称**(例如, color_、shape_或x_)最后以标度的名称结尾(例如gradient、hue或manual)。从表中可以发现, 标度是区分离散和连续变量的, 因此再对标度进行调整一定要注意区分。ggplot2中的标度可以粗略的分为4类：**(1)位置标度**:用于将连续型、离散型和日期-时间型变量映射到绘图区域, 以及构造对应的坐标轴; (2)颜色标度：用于将连续型和离散型变量映射到颜色; (3)手动离散型标度：用于将离散型变量映射到我们选择的符号大小、线条类型、形状或颜色, 以及创建对应的图例; 以及**(4)同一型标度：**用于直接将变量值绘制为图形属性, 而不去映射他们。 实际应用中修改标度最长用的有3个方面**(1)修改图例和(2)修改图形属性和(3)修改坐标轴** 8.分面 即在一个页面上自动摆放多幅图形, 这一过程先将数据划分为多个子集, 然后将每个子集依次绘制到页面的不同面板中。ggplot2提供两种分面类型：网格型(facet_grid)**和封面型(facet_wrap)。网格分面生成的是一个2维的面板网格, 面板的行与列通过变量来定义, 本质是2维的; **封装分面则先生成一个1维的面板条块, 然后再分装到2维中, 本质是1维的 1234567p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()p + facet_grid(. ~ cyl) #以cyl为分类变量p + facet_wrap( ~ cyl, nrow = 3) #wrap与grid的区别p + facet_grid(cyl ~ .) #以cyl为分类变量p + facet_wrap( ~ cyl, ncol = 3) #wrap与grid的区别p + facet_grid(vs ~ am) #以vs和am为分类变量p + facet_wrap(vs ~ am, ncol = 2) #wrap与grid 的区别 12345p &lt;- p + geom_smooth(method = \"lm\", se =F, aes(color = factor(cyl))) + geom_point(aes(color = factor(cyl)))p + facet_grid(vs ~ am)p + facet_grid(vs ~ am, margins = T) #使用margins来描述边际图p + facet_grid( ~ cyl, scales = \"free\")p + facet_grid( ~ cyl, scales = \"free_x\") # scale 可取 \"fixed\" \"free\" \"free_x\" \"free_y\" 坐标刻度的范围，可以设定四种类型。fixed 表示所有小图均使用统一坐标范围；free表示每个小图按照各自数据范围自由调整坐标刻度范围；free_x为自由调整x轴刻度范围；free_y为自由调整y轴刻度范围。 1234567# 例子有问题，cty, hwy不知道是什么p &lt;- ggplot(aes(cty, hwy), data = mtcars) + geom_point()p + facet_wrap( ~ cyl)#调整scales的标度, 共有fixed, free, free_x和free_y四种变换p + facet_wrap( ~ cyl, scales = \"free\") # 这里标度更改为freep + facet_grid(. ~ cyl, scales = \"free\", space = \"free\")#space设置为free时, 每列的宽度 与 该列的标度范围成比例，就是每一个图的宽度与横坐标的范围成正比 9.主题主题系统控制着图形中的非数据元素外观, 它不会影响几何对象和标度等数据元素。主题修改是一个对绘图精雕细琢的过程, 主要对标题、坐标轴标签、图例标签等文字调整, 以及网格线、背景、轴须的颜色搭配。 内置元素共有四个基础类型：文本(text), 线条(line)、矩形(rectangle)、空白(blank), text与其他类型操作相类似 123p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point() + labs(title = \"histogram\")p + theme(plot.title = element_text(size =20, color = \"red\",hjust = 0, face = \"bold\", angle = 180))p + theme(panel.background = element_blank()) # 去除背景 10.保存输出123p &lt;- ggplot(mtcars, aes(x = mpg, y = disp)) + geom_point()ggsave( file = \"mtcars_plot.png\", width = 5, height = 6, type = \"cairo\", dpi = 600) # cairo为抗锯齿包, ggplot默认输出即为cairo处理 高质量图片输出 在ggplot2我比较推荐的图片输出格式为经过Cairo包处理的PDF，因为PDF格式体积小，同时可以储存为其他任何格式，随后再将PDF储存为eps格式并在Photoshop中打开做最终的调整，例如调整比例、色彩空间和dpi（一般杂志和出版社要求dpi=300以上）等。额外需要注意的是ggplot2中的字体大小问题，在cookbook-r一书中指出，在ggplot2中绝大多数情况下，size的大小以mm记，详细的讨论也可以参考stackover的讨论，而在theme()中对element_text()里的size进行调整，此时的size是以磅值（points, pts）来进行表示 123456789101112131415161718192021222324252627require(ggplot2)require(Cairo)ggplot() + geom_text(aes(x = 16, y = 16), label = \"ABC\", size = 11.28) + #尺寸为11.28mm，即为32磅 geom_text(aes(x = 16, y = 14.5), label = \"ABC\", size = 32) + #尺寸为32mm labs( x = \"x axis\", y = \"y axis\") + ylim( c(14, 16.5)) + xlim( c(15.75, 16.25)) + theme( axis.title.x = element_text(size = 32),#尺寸为32磅 axis.title.y = element_text(size = 32))#尺寸为32磅 x &lt;- seq(-4,4, length.out = 1000)y &lt;-dnorm(x)data &lt;- data.frame(x, y) #用Cairo包输出require(Cairo)CairoPDF(\"plot1.pdf\", 3.15, 3.15) #单位为英寸ggplot(data, aes(x = x, y = y)) + geom_line(size = 1) + theme_bw()dev.off() #关闭图像设备，同时储存图片 plot2 &lt;- ggplot(data, aes(x = x, y = y)) + geom_line(size = 1) + theme_bw()#用ggsave输出，默认即以用Cairo包进行抗锯齿处理ggsave(\"plot2.pdf\", plot2, width = 3.15, height = 3.15)#RStudio输出 中文字体12345678910111213141516171819202122#showtextrequire(showtext)require(ggplot2)require(Cairo)font_add(\"BlackoakStd\", \"C://Windows//Fonts//BlackoakStd.otf\")font_add(\"BrushScriptStd\", \"C://Windows//Fonts//BrushScriptStd.otf\")font_add(\"times\", \"C://Windows//Fonts//times.ttf\")font_add(\"STHUPO\", \"C://Windows//Fonts//STHUPO.ttf\")CairoPDF(\"showtext_output\", 8, 8)showtext.begin()ggplot() + geom_text(aes(x = 16, y = 16.25), label = \"Blackoak Std\", size = 8, family = \"BlackoakStd\") + geom_text(aes(x = 16, y = 16), label =\"Brush Script Std\", size = 16, family = \"BrushScriptStd\") + geom_text(aes(x = 16, y = 15.75), label = \"Times New Roman\", size = 16, family = \"times\") + geom_text(aes(x = 16, y = 15.50), label = \"华文琥珀\", size = 16, family = \"STHUPO\") + ylim(c(15.25, 16.50)) + labs(x = \"\", y = \"\") + theme_bw() #在用RStudio输出 BTW 补充知识参考 金子哦ggplot2 系列教程 1.从例子中学理论1234567length(ggplot())names(ggplot())str(ggplot())ggplot()$datap &lt;- ggplot(diamonds) + geom_point() + aes(x=carat, y=price, color = color, shape= cut)p$layers 一个图层包含了至少3个东西（数据和映射当然必需，另算）：geom、stat和position 几何类型 geom：是数据在图上的展示形式，即点、线、面等。在ggplot2里面有很多预定义的几何类型。 统计类型 stat：是对数据所应用的统计类型/方法。上面的p2和p3对象我们并没有指定统计类型，但是自动获得了identity，因为ggplot2为每一种几何类型指定了一种默认的统计类型，反之亦然。所以如果仅指定geom或stat中的一个，另外一个会自动获取。 位置 position：几何对象在图像上的位置调整，这也有默认设定。 图层加法 = 图层按照顺序的叠加 2.映射ggplot2按照图形属性提供了以下可用映射类型： 颜色类型映射：包括 color（颜色或边框颜色）、fill（填充颜色）和 alpha（透明度） 形状类型映射：包括 linetype（线型）、size（点的大小或线的宽度）和 shape（形状） 位置类型映射：包括 x, y, xmin, xmax, ymin, ymax, xend, yend 特殊类型：包括两类，一类是指定数据分组和顺序的映射group和order，另一类是字符串映射。 ggplot2对映射应用的标尺可以修改，ggplot提供了一大批 scale_xxxxxxxx 类型的函数，比如 scale_color_xxxx 类型函数用户修改颜色标尺，scale_shape_xxxx 修改形状，scale_linetype_xxxx 修改线型等。按照数据的类型，这些函数还有4种基本类型： continuous：连续型 discrete：离散型 identity：和数据取值相同 manual：手工指定 映射会自动产生图例 非映射 即 设定1234p + geom_boxplot(aes(x=cut, fill=cut)) + scale_fill_manual(values=rep(\"cyan\", length(levels(d.sub$cut))))p + geom_boxplot(aes(x=cut), fill=\"cyan\") # 设定没有图例，而且 fill=\"cyan\"不在 aes()里面 ymin/ymax 可以画出 带有误差线的散点图，无需使用errorbar设置 12345678dmod &lt;- lm(price ~ cut, data = diamonds)cuts &lt;- data.frame(cut = unique(diamonds$cut), predict(dmod, data.frame(cut =unique(diamonds$cut)), se = TRUE)[c(\"fit\", \"se.fit\")])se &lt;- ggplot(cuts, aes(x = cut, y = fit, ymin = fit - se.fit, ymax = fit + se.fit, colour = cut))se + geom_pointrange()# 或者像这样se + geom_point() + geom_errorbar(width=0.2)se + geom_bar(stat=\"identity\", aes(fill=cut)) + geom_errorbar(width=0.2) 在ggplot2作图过程中，映射的处理在先于其他绘图步骤，也先于统计运算。颜色和形状类型的映射会对数据进行分组，统计运算使用的也是分组后的数据。 123456ggplot(d.sub, aes(x=carat, y=price, color=cut)) + geom_point() + geom_smooth(aes(group=1), method=\"lm\", se=FALSE)# 本来按cut分组后的数据恢复为1组来进行回归计算ggplot(d.sub, aes(x=carat, y=price, color=cut)) + geom_point() + geom_smooth(aes(group=color, linetype=color), method=\"lm\", se=FALSE, color=\"black\")# 在回归统计分析中重新按照color来对数据分组，并映射为线条类 不同图形对X轴数据类型的要求是不一样的，曲线图要用连续型数据，而柱形图要用因子型（或离散型）数据，这两类图形如果不经特殊处理就不能放在一起。group映射可以轻松搞定它 123se + geom_bar(stat=\"identity\", aes(fill=cut)) + geom_errorbar(width=0.2) + coord_cartesian(ylim=c(3000,4800)) + geom_line(aes(group=1), color=\"black\")# group重新将数据整合为1组来画折线图 order映射用于改变数据类型的排序。注意是在图层中的排列顺序而不是图例的先后顺序 ，也就是颜色的叠加顺序 123p + geom_point(aes(color=cut, order=cut))library(plyr) # 使用desc函数p + geom_point(aes(color=cut, order=desc(cut))) ggplot2作图详解4：分面facet_wrap 1234567891011121314library(ggplot2)# 准备数据set.seed(100) # 产生随机编号，在取随机数之前必做，保证每个人取到的随机数是相同的d.sub &lt;- diamonds[sample(nrow(diamonds), 500), ]head(d.sub, 4)theme_set(theme_bw())p &lt;- ggplot(data=d.sub, aes(x=carat, y=price))p + geom_point() + facet_wrap(~cut)# usagefacet_wrap(facets, nrow = NULL, ncol = NULL, scales = \"fixed\", shrink = TRUE, as.table = TRUE, drop = TRUE)# shrinks：也和坐标轴刻度有关，如果为TRUE（默认值）则按统计后的数据调整刻度范围，否则按统计前的数据设定坐标# as.table：和小图排列顺序有关的选项。如果为TRUE（默认）则按表格方式排列，即最大值（指分组level值）排在表格最后即右下角，否则排在左上角# drop：是否丢弃没有数据的分组，如果为TRUE（默认），则空数据组不绘图 facet_grid 123456# usagefacet_grid(facets, margins = FALSE, scales = \"fixed\", space = \"fixed\", shrink = TRUE, labeller = \"label_value\", as.table = TRUE, drop = TRUE)# exampleqplot(carat, price, data=diamonds, alpha=I(0.2)) + facet_grid(color~cut, margins=TRUE)# color~cut 对数据的分组和小图排列有决定作用，波浪号前为小图分 行标准，后面为分 列标准，因此不同设置行/列数# margins为T时会增加一行数据和一列数据，所有行数据整合叠加在一起，所有列数据整合叠加在一起。 图形语法和图形组合1.几何/统计类型设置函数在ggplot2中，每种几何类型都有对应的（默认）统计类型，反之亦然。两者不分家，所以得放在一起来说。换言之，一般只需要设置其中一个，另一个会设置为对应的（默认）统计类型。几何类型的设置函数全部为geom_xxx形式，而统计类型设置函数全部为stat_xxx的形式 1234567891011121314151617181920# 可通过一下代码查看library(ggplot2)ls(\"package:ggplot2\", pattern=\"^geom_.+\")ls(\"package:ggplot2\", pattern=\"^stat_.+\")# usagegeom_point(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", na.rm = FALSE, ...)stat_identity(mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", width = NULL, height = NULL, ...)# ggplot(data,aes())data参数在前，mapping参数在后，而geom/stat是mapping在前，可以不用参数，因为作图前数据都已确定set.seed(100)d.sub &lt;- diamonds[sample(nrow(diamonds), 500),]p &lt;- ggplot(d.sub, aes(x=carat, y=price))theme_set(theme_bw())p + stat_identity()p + geom_point()# 两个是一样的，因为 geom_point()对应的统计类型就是 stat_identity() 具体二者对应信息参考组学大讲堂 Btw： 有些数据包只有特定的R包才会内置，而有些是R自带的基础包 12data() # 查看自带的包data(package = .packages(all.available = T)) # 查看R包自带的数据集 2.图层组合 图层的组合不是连续使用几个几何或统计类型函数那么简单。ggplot函数可以设置数据和映射，每个图层设置函数（geom_xxx和stat_xxx）也都可以设置数据和映射 2.1简单组合不同图层使用同一套数据，只是几何类型或统计类型有差别。这是最简单也是最常用的，用ggplot函数设置好数据和映射，把几个图层加起来即可。 1234datax &lt;- data.frame(x=1:10, y=rnorm(10)+1:10)p &lt;- ggplot(datax, aes(x=x, y=y))p + geom_point() + geom_line()p + geom_point() + geom_smooth(method=\"lm\") ggplot2的图层设置函数对映射的数据类型是有较严格要求的，比如geom_point和geom_line函数要求x映射的数据类型为数值向量，而geom_bar函数要使用因子型数据。如果数据类型不符合映射要求就得做类型转换，在组合图形时还得注意图层的先后顺序。 12345p &lt;- ggplot(datax, aes(x=factor(x), y=y)) + xlab(\"x\")p + geom_bar(stat=\"identity\", fill=\"gray\") + geom_line(aes(group=1), size=2) + geom_point(color=\"red\")p + geom_bar(stat=\"identity\", fill=\"gray\") + geom_smooth(aes(group=1), method=\"lm\", se=FALSE, size=2) # 先做barplot（因子型），再做散点图（连续性数值向量） 2.2不同映射组合 映射反映的是数据变量。多数情况下一个图形中使用的是同一个数据集，只是变量不同。通常情况下x，y轴至少有一个是相同的，可以用不同图层叠加不同的数据变量 ，明智的办法是`reshape2`中的`melt()`变形数据，将不同变量移到同一列作为因子型 12345678p &lt;- ggplot(d.sub, aes(x=carat)) + ylab(\"depth (blue) / table (red)\")p + geom_point(aes(y=depth), color=\"blue\") + geom_point(aes(y=table), color=\"red\")# 明智之举library(reshape2)datax &lt;-melt(d.sub, id.vars=\"carat\", measure.vars=c(\"depth\", \"table\"))ggplot(datax, aes(x=carat, y=value, color=variable)) + geom_point() 2.3 不同类型数据的组合 如果在geom_xxx函数中改变数据会怎么样呢？不同类型的数据一般不会有完全相同的变量，否则就不是“不同类型”了，所以映射也会相应做修改。下面把钻石数据diamonds和汽车数据mtcars这两个风牛马不相及的数据放在一起看看 1234567891011121314151617181920data(mtcars)p &lt;- ggplot(data=d.sub, aes(x=carat, y=price, color=cut)) # diamonds数据layer1 &lt;- geom_point(aes(x=carb, y=mpg), mtcars, color=\"black\") # mtcars数据p1 &lt;- p + layer1# 图中数据点是正确的，但坐标轴标题却对不上号。看看ggplot对象的数据、映射和图层；head(p1$data,4)p1$mappingp1$layers# 数据和映射都还是ggplot原来设置的样子，layer2图层设置的都没有存储到ggplot图形列表对象的data和mapping元素中，而是放在了图层中，但图层中设定的数据不知道跑哪里。如果再增加一个图层，把坐标轴标题标清楚：layer2 &lt;- geom_point(aes(y=depth))p1 &lt;- p1 + layer2 + xlab(\"carb(black) / carat\") + ylab(\"mpg(black) / depth\")# layer2重新指定了y映射，但没碰原来ggplot对象设置的x和color映射，从获得的图形来看y数据改变了，x和color还是原ggplot对象的设置。查看一下映射和图层p1$mappingp1$layers# 可以这么理解：ggplot2图层作图时依次从ggplot对象和图层中获取数据/映射，如果两者映射有重叠，后者将替换前者，但只是在该图层中进行替换而不影响ggplot对象。# 如果ggplot对象的映射比图层的映射多，而图层又使用了不同的数据，这是什么情况？看看p + geom_point(aes(x=carb, y=mpg), mtcars)# 由于图层继承了ggplot对象的color映射，但又找不到数据，所以没法作图。解决办法是把原有的映射用NULL取代，或者设为常量（非映射）p + geom_point(aes(x=carb, y=mpg, color=NULL), mtcars)p + geom_point(aes(x=carb, y=mpg), mtcars, color=\"red\") 标度（scale）设置123456789101112131415161718192021222324252627282930313233343536373839404142library(ggplot2)scalex &lt;- ls(\"package:ggplot2\",pattern = \"^scale.+\")scalex &lt;- scalex[grep(\"([^_]+_){2}.+\", scalex)]unique(gsub(\"(([^_]+_){2}).+\",\"\\\\1***\",scalex))# 可以看到标尺设置的内容有8种（颜色color/colour算一种）：线条颜色、填充色、透明度、线型、形状、大小，x和y轴。# 标尺设置的内容都有对应的映射设置类型，但映射比标尺多了xmin, xmax, ymin, ymax, xend, yend，group和string等# 线条颜色scalexx &lt;- scalex[grepl(\"scale_color.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"brewer\" \"continuous\" \"discrete\" \"gradient\" \"gradient2\" ## [6] \"gradientn\" \"grey\" \"hue\" \"identity\" \"manual\" \"viridis_c\" \"viridis_d\" # 填充色scalexx &lt;- scalex[grepl(\"scale_fill.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"brewer\" \"continuous\" \"discrete\" \"gradient\" \"gradient2\" ## [6] \"gradientn\" \"grey\" \"hue\" \"identity\" \"manual\" \"ordinal\" \"viridis_c\" \"viridis_d\"# 大小scalexx &lt;- scalex[grepl(\"scale_size.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"area\" \"continuous\" \"discrete\" \"identity\" \"manual\" \"ordinal\" # 透明度scalexx &lt;- scalex[grepl(\"scale_alpha.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"continuous\" \"discrete\" \"identity\" \"manual\" \"ordinal\" # 线型scalexx &lt;- scalex[grepl(\"scale_linetype.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"continuous\" \"discrete\" \"identity\" \"manual\"# 形状scalexx &lt;- scalex[grepl(\"scale_shape.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"continuous\" \"discrete\" \"identity\" \"manual\" \"ordinal\"# x轴scalexx &lt;- scalex[grepl(\"scale_x.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"continuous\" \"date\" \"datetime\" \"discrete\" \"log10\" ## [6] \"reverse\" \"sqrt\" \"time\"# y轴scalexx &lt;- scalex[grepl(\"scale_y.+\", scalex)]unique(gsub(\"(([^_]+_){2})(.+)\",\"\\\\3\",scalexx))## [1] \"continuous\" \"date\" \"datetime\" \"discrete\" \"log10\" ## [6] \"reverse\" \"sqrt\" \"time\" 除坐标轴外，其它标尺都有四种基本设置函数：”continuous”，”discrete”，”identity”和”manual”。结合标尺的作用和设定方法两个标准，H.W把它们分为4种类型的标尺：位置、颜色、无变换和人工设置类型（详情参考相关书籍）。颜色设置相关的函数较多，线条颜色和填充色设置的函数类型基本一致，而x轴和y轴设置的函数类型也一样 例子举了 颜色标尺 和 坐标轴标尺，在这里就不细说了，直接参考原帖。 主题(theme)设置12345678910111213library(ggplot2)theme_gray()# 所有元素都在theme函数内使用element_line，element_rect，element_text和element_blank函数设置x &lt;- LETTERS[1:10]; y &lt;- abs(rnorm(10))p &lt;- qplot(x=x, y=y, color=x, fill=x, geom=c('line','point'), group=1) + labs(title='The figure title.', xlab='Factor', ylab='Value') + theme(text=element_text(color='red', size=16), line=element_line(color='blue'), rect=element_rect(fill='white'))p + theme(panel.background=element_rect(fill='transparent', color='gray'), legend.key=element_rect(fill='transparent', color='transparent'), axis.text=element_text(color='red'))# 全局text和rect设置对部分元素有作用，line基本不起作用 自定义主题12345678910111213141516171819202122232425262728##' A nice-looking ggplot2 theme: inward axis ticks, legend title excluded, and uniform background.##' @title A nice-looking ggplot2 theme##' @param ...##' Parameters passed to theme_classic() function.##' @param bg##' Color string (default 'white') for user defined uniform background.##' @return##' ggplot2 theme object.##' @example##' library(ggplot2)##' qplot(x=carat, y=price, color=cut, data=diamonds) + theme_zg()##' @author ZG Zhao##' @exporttheme_zg &lt;- function(..., bg='white'){ require(grid) theme_classic(...) + theme(rect=element_rect(fill=bg), plot.margin=unit(rep(0.5,4), 'lines'), panel.background=element_rect(fill='transparent', color='black'), panel.border=element_rect(fill='transparent', color='transparent'), panel.grid=element_blank(), axis.title = element_text(color='black', vjust=0.1), axis.ticks.length = unit(-0.4,\"lines\"), axis.ticks = element_line(color='black'), axis.ticks.margin = unit(0.8,\"lines\"), legend.title=element_blank(), legend.key=element_rect(fill='transparent', color='transparent'))}","link":"/2020/08/15/ggplot2/"},{"title":"生物统计学基础知识","text":"​ 本文内容均来自李春喜编著的《生物统计学》第五版，属于个人总结的读书笔记。如果侵犯版权，请联系删除！ ​ 生物统计学主要包括试验设计和统计分析，前者指应用统计的原理方法制定试验方法，选择实验材料，合理分组，使用较少的人力物力，时间获得较多而可靠的数据资料；后者指应用数理统计的原理与方法对数据资料进行分析与推断，主要包括统计描述与统计推断，设计数据资料的收集与整理，特征数计算，假设检验，方差分析，回归和相关分析，协方差分析。前者是后者的运用，后者为前者提供依据。主要包括这几个内容： 提供整理和描述数据资料的分析方法，确定某些性状和特性的数量特征； 判断实验结果的可靠性； 提供由样本推断总体的方法； 提供试验设计的一些原则； 统计学术语： 总体VS个体 参数VS统计数 变量与资料 因素与水平 处理与重复 互作与效应 准确性与精确性 误差（随机与系统）与错误 1.样本的特征数集中性 平均数（算术/几何（log)) x拔 μ 离均差和为0 离均差平方和最小 分位数（四分位数，箱线图，Q1~Q3，从小到大） 离散性 方差(variance,MS)：样本方差，总体方差，求根得标准差$$s^{2} = \\frac{\\sum(x-\\overline x)}{n-1}$$ $$\\sigma^2 = \\frac{\\sum(x-\\overline x)}{N}$$ n-1为自由度，N为有限总体容量，$ s^2 $ 是$\\sigma^2$ 的最好估计（无偏估计值），这里涉及到除以n-1 变异系数 衡量一个样本变量分布变异程度的重要参数，排除平均数的干扰 CV = $\\frac{s}{\\overline x}$ 2.概率与概率分布基本原理：大数定量：当样本容量n足够大时，可以用样本统计数对总体参数做出估计。 常见概率分布为离散型随机变量的二项分布（伯努利分布），泊松分布和连续型随机变量的正态分布 2.1 二项分布(binomial distribution)​ 每次实验两个结果，可重复进行，且结果独立 x表示n次实验中事件A发生的次数,A发生的概率是p，x是一个离散型随机变量，所有可能取值是0,1,2，…n，其概率分布函数是: $P(x)$=$C_n^x p^xq^{n-x}$ 其中$C_n^x$ =$\\frac{n!}{x!(n-x)!}$ 我们称P(x)为随机变量x的二项分布，记作B(n,p) 之所以称之为二项分布，因为 $C_n^x p^xq^{n-x}$ 正好是 $(p+q)^n$ 牛顿二项式的第 n +1 项，也被称为 伯努利分布(Bernoulli distribution)，二项分布的概率累计函数是：$F(x)$=$\\sum_{x=0}^{i}P(x)$ 大写。 二项分布的形状由n和p决定，当p较小时 图形是偏倚的，当n增加，分布逐渐对称；p值趋于0.5，分布趋于对称 二项分布的参数：总体平均数 $\\mu$ = np，总体标准差 $\\sigma_{x}$ = $\\sqrt{npq}$ 2.2 泊松分布(Poisson distribution)​ 生物学研究中，许多事件出现的概率很小，但样本容量或实验次数很大，即p很小，n很大。二项分布就成为了泊松分布，比如显微镜视野中染色体有变异的细胞计数，由突变而引起的遗传病患者的分布。在重测序(找SNP)中，基因组中有1万个碱基，每次随机测一个碱基，任意一个碱基被测到的概率为0.0001，如果我测了10万次，那么某一个碱基被测到5次（测序深度）的概率是多少？这里就符合泊松分布，然后RNA-seq的基因表达量也可以类比于重测序中的每一个碱基的测序深度，只是重测序中每个碱基被测到的概率是一样的，而由于每个转录本的表达量不同，那么每一个转录本的reads被测到的次数和方差就各不相同而已(摘自OmicShare 第14期的PPT)。（不是很理解后面RNAseq对基因的表达定量也符合泊松分布）。泊松分布本身也是一种离散型随机变量的分布。其概率分布函数为：$P(x)$ = $\\frac{e^{-\\lambda}\\lambda^{x}}{x!}$ ， 大写 $\\lambda$ 为参数，$\\lambda$ =$np$ $\\mu$=$\\lambda$ ，$\\sigma^{2}$=$\\lambda$ 具有参数$\\lambda$符合泊松分布记做 $P(\\lambda)$。由于泊松分布是描述小概率事件的，因而二项分布P&lt; 0.1, np&lt;5 可以用泊松分布来近似。 2.3 正态分布( Normal distribution/ Gauss distribution)​ 一种连续型随机变量的概率分布，分布状态是多数变量都围绕在平均值左右，由平均值到分布的两侧，变量数减少。可能是最重要的分布。试验误差的分布一般服从于正态分布，许多生物现象的计量资料均近似服从正态分布 。同时在一定条件下，正态分布还可作为离散型随机变量或其他连续型随机变量的近似分布。例如，当n相当大，或p与q近似相等，二项分布接近于正态分布，当 $\\lambda$ 较大时，泊松分布也接近于正态分布。有些总体虽然可能并不服从正态分布，但从总体中随机抽取的样本容量相当大时，其样本平均数的分布也近似于正态分布，这样，就能用正态分布代替其他分布进行概率随计算和统计推断。正态分布的概率密度函数： $f(x)$=$\\frac{1}{\\sigma \\sqrt{2\\pi}}e^{-\\frac{(\\frac{x-\\mu}{\\sigma})^2}{2}}$ 概率密度函数 VS 概率分布函数 ：前者求积分就得到后者，后者求导得到前者，分布函数直接得到的就是概率，而概率密度函数在某一个区间内的积分才是概率。二者表示也不同，前者是大写的，后者是小写的 正态分布记为N($\\mu$,$\\sigma^2$)表示具有平均数为 $\\mu$，方差为 $\\sigma^2$ 的正态分布。正态分布曲线为钟形曲线 标准正态分布 通过 $u=\\frac{x-\\mu}{\\sigma}$ ，任何一个符合标准正态分布的随机变量$x$ 都可以标准化为 $f(x)$=$\\frac{1}{\\sigma \\sqrt{2\\pi}}e^{-\\frac{u^2}{2}}$ 标准正态分布的概率累积函数 $F(u_{i})=P(u&lt;u_{i})=\\int_{-\\infty}^{u_{i}}{f(u)du}$ 表示 变量 $u$ 小于某一定值 $u_{i}$ 的概率 对于$u$落在 区间[a,b]的概率，有：$P(a \\le u \\le b) = \\int_{a}^{b}{\\frac{1}{\\sigma \\sqrt{2\\pi}}e^{-\\frac{u^2}{2}}du}$ 在例子 $|x-\\mu|&gt;1.96\\sigma$ 和 $|x-\\mu|&gt;2.58\\sigma$ 时用到了双尾概率，即左尾概率和右尾概率之和，正态利差$u$ 值表列出了两尾概率取某一显著水平$\\alpha$ 时的 $u$ 临界值，即分位数，记为 $u_{a}$ 比如： p=0.01，$u_{0.01}=2.58$ ； p=0.05，$u_{0.01}=1.96$ 2.4 负二项分布摘自维基百科： 负二项分布是统计学上一种描述在一系列独立同分布的伯努利试验中，失败次数到达指定次数（记为r）时成功次数的离散概率分布。比如，如果我们定义掷骰子随机变量x值为x=1时为失败，所有x≠1为成功，这时我们反复掷骰子直到1出现3次（失败次数r=3），此时非1数字出现次数的概率分布即为负二项分布。 当r是整数时又称帕斯卡分布 在实际生活中，我们可以使用负二项分布描述某种机器在坏掉前，能够工作的天数的分布。此时，“成功”的事件可以指机器正常工作一天，“失败”的事件可以指机器故障的一天。如果我们使用负二项分布来描述运动员在获取r个奖牌前尝试的次数的分布，此时，“成功”的事件指运动员的一次尝试，“失败”的事件指运动员获取一枚奖牌。如果使用负二项分布来描述掷一枚硬币出现r次反面前，出现硬币正面的次数的分布，“成功”的事件指出现硬币的正面，“失败”的事件指出现硬币的反面。 其概率质量函数(相当于离散随机变量中的概率密度函数)： $f(k;r;p)=P(x=k)=C_{r+k-1}^{k}{p^k(1-p)^r}$ ​ 其中k是成功的次数，r是失败的次数，p是事件成功的概率。在负二项分布的概率质量函数中，由于k+r次伯努利试验为独立同分布，每个失败r次、成功k次的事件的概率为$(1-p)^rp^k$ 。由于第r次失败一定是最后一次试验，所以应该在k+r-1次试验中选择k次成功，使用排列组合二项系数获取所有可能的选择数。 当r=1时，负二项是二项分布。 负二项分布的均值和方差： $\\mu=\\frac{pr}{1-p}$ $\\sigma^2=\\frac{pr}{(1-p)^2}$ 负二项分布主要运用在差异表达分析中。 2.5 gamma分布 &amp;&amp; 超几何分布略 3. 统计数的分布3.1 抽样试验与无偏估计目的：从总体到样本，即从一般到特殊，主要是要了解从总体到从总体中所抽取样本的变异特点。 ​ 从理论上讲，从一个总体中抽取所有可能的样本，就能获得有关统计数变异的全部信息，但实际不可能。解决办法是 抽取一部分，或者对小的有限总体放回式抽样，又称复置抽样。 ​ 无偏估计：在统计上，如果所有可能样本的某一统计数的平均数等于总体的相应参数，则称该统计数为总体相应参数的无偏估计值（unbiased estimated value）。根据书中P47 表3-6所示结果可以得到一下结论： ​ 在一个符合正态分布的总体中（3,4,5）有放回抽两个得到的所有可能样本中， 样本平均数$\\bar x$ 是总体平均数$\\mu$ 的无偏估计值； 样本方差$s^2$ 是总体方差数$\\sigma^2$ 的无偏估计值； 样本标准差$s$ 不是总体标准差$\\sigma$ 的无偏估计值； 3.2 样本平均数的分布​ 从总体中抽出的样本为每一个可能样本，且每个样本中的变量均为随机变量，所以其样本平均数也为随机变量，也形成一定的理论分布，称之为 样本平均数的概率分布，或者样本平均数的分布（distribution of the sample mean)。从抽样试验中可得出样本平均数分布有以下基本性质： 样本平均数分布的平均数等于总体平均数，即 $\\mu_{\\bar x} = \\mu$ 样本平均数分布的方差等于总体方差除以样本容量，即 $\\sigma_{\\bar x}^2=\\frac{\\sigma^2}{n}$ ，两边开根号得： $\\sigma_{\\bar x} = \\frac{\\sigma}{\\sqrt{n}}$ 即 样本平均数的标准误 如果从正态总体$N(\\mu,\\sigma^2)$ 进行抽样，其样本平均数$\\bar x$ 是一个具有平均数$\\mu$，方差 $\\frac{\\sigma^2}{n}$ 的正态分布，记作$N(\\mu,\\frac{\\sigma^2}{n})$ 如果抽样总体不是正态总体，但具有平均数$\\mu$ 和方差 $\\sigma^2$ ，但样本容量$n$ 不断增加，样本平均数$\\bar x$ 的分布也越来越接近正态分布，且具有 具有平均数$\\mu$，方差 $\\frac{\\sigma^2}{n}$ ，这称为 中心极限定理。不论总体为何分布，一般只要样本容量大于等于30,就属于大样本，就可应用中心极限定理，认为样本平均数$\\bar x$ 的分布是正态分布。 3.3 样本平均数差数的分布​ 两个相互独立的正态总体，平均数差数分布的性质： 样本平均数差数的平均数等于总体平均数的差数 $\\mu_{\\bar x_1- \\bar x_2} = \\mu_{\\bar x_{1}} - \\mu_{\\bar x_{2}}$ 样本平均数差数的方差等于总体方差除以各自样本容量之和 $\\sigma_{\\bar x_{1}-\\bar x_{2}}^2 =\\frac{\\sigma_{1}^2}{n_{1}} + \\frac{\\sigma_{2}^2}{n_{2}} = \\sigma_{\\bar x_{1}}^2+ \\sigma_{\\bar x_{2}}^2$ 开根号就得 样本平均数差数的标准误 从两个独立正态总体中抽出的样本平均数差数的分布也是正态分布，并具有 平均数 $\\mu_{\\bar x_{1}} - \\mu_{\\bar x_{2}}$ 和方差 $\\sigma_{\\bar x_{1}-\\bar x_{2}}^2$ ，记作 $N(\\mu_{\\bar x_{1}} - \\mu_{\\bar x_{2}},\\sigma_{\\bar x_{1}-\\bar x_{2}}^2)$ 3.4 $t$ 分布​ 在实际研究过程中，会遇到 总体方差未知，且样本容量不大 小于30，如果仍用 $s^2$ 来估计 $\\sigma^2$ ，此时 $\\frac{\\bar x-\\mu}{\\frac{s}{\\sqrt{n}}}$ 服从自由度为 df=n-1的$t$ 分布 $t = \\frac{\\bar x-\\mu}{s_{\\bar x}}=\\frac{\\bar x-\\mu}{\\frac{s}{\\sqrt{n}}}$ 其中 $s_{\\bar x}$ 为 $\\sigma_{\\bar x}$ 的估计值 $t$ 分布具有以下特征 左右对称 ，围绕 $\\mu_{t} = 0$ 向两侧递降； 受自由度 df = n -1 制约，一个自由度对应一条曲线； 各种自由度下的 t值可从表中读取 3.5 $\\chi^2$分布(卡方分布)\\​ 假设从标准正态总体 中抽取$k$ 个独立样本，就会得到 $u_{1}^2，u_{2}^2，u_{3}^2，…，u_{k}^2 $ 则 它们的和为 $\\chi^2$ ，$\\chi^2$ 分布的自由度$df=k-1$。是连续型变量的分布，每个自由度对应一个。特征： 分布区间为0 到正无穷 存在右尾概率 3.6 $F$ 分布​ 设从一正态总体$N(\\mu，\\sigma^2)$ 中随机抽取样本容量为$n_1$ 和 $n_2$ 的两个独立样本，其样本方差为 $s_1^2$ ，$s_2^2$ 则定义二者比值为$F$ : $F= \\frac{s_1^2}{s_2^2}$ 此$F$ 值具有 $s_1^2$ 的自由度 $df_1=n_1-1$，$s_2^2$ 的自由度 $df_2 = n_2-1$ 。如果对以正态总体在特定的 $df_1 $ $df_2$ 下进行一系列随机独立抽样，则所有可能的 $F$ 值就构成一个 $F$ 分布，有如下性质： 取值范围为[0，$+\\infty$] 右尾概率 4. 统计推断4.1 假设检验生物统计学中假设检验（又称显著性检验）的方法，需要提出两个彼此对立的假设： $H_{0}$ 又称无效假设、零假设, 指二者表达没有真实差异，表达量的不同可能是处理过程的误差造成的，即处理无效； $H_{A}$ 又称备择假设，指二者表达确实存在差异，而这种差异是来自于不同样品间的处理造成的，即处理有效。 接着我们计算在$H_{0}$ 假设 成立的概率，即随机误差产生的概率。如果这个概率很低，低于我们设置的显著水平 $\\alpha$ （0.05或0.01），那么我们就可以在这个显著水平下否定原假设，接受备择假设，认为该基因在两个样本中表达具有显著差异。当然还是有可能真是的结果是没有差异，但这个判断犯错的概率是$\\alpha$，也就是假阳性率。这是针对单个基因在两个样本中表达是否显著性的检验。 假设检验4步： 提出假设； 确定显著水平 $\\alpha$ = 0.05/0.01，否定 $H_0$ 的概率标准； 计算统计数和概率水平，这里计算并不是实得差异本身的概率，而是超过实得差异的概率； 推断是否接受差异； 根据小概率原理：如果假设一些条件，并在假设的条件下能够准确的算出事件 A 出现的概率 $\\alpha$ 为很小，则在假设调价下的 n次独立重复试验中，事件 A将按预定的概率发生，而在一次实验中则几乎不可能发生。即小概率事件在一次抽样试验中几乎不可能发生，计算概率 &gt; 0.05 或 0.01，则认为不是小概率事件， 可接受原假设，否则，接受 备择假设。P &lt; 0.05 为差异显著，*表示，P &lt; 0.01为极显著，**表示。 可结合书中P55-57例子理解。 双尾检验和单尾检验：​ 如果问题是两个组样本或者样本是否来源于某个平均数，方差已知的总体。有差异，就是双尾检验，因为可能是A大于B，也有可能A小于B。所以是双尾检验。 ​ 但是在某种情况下，双尾检验不符合实际，比如检验某种新药与旧药相比，疗效是否有差异，在实际情况下，新药疗效不可能不如旧药，这时就只有一种可能，要么好，要么差，相应的概率也只能考虑一侧，像这种只考虑一侧的称之为单尾检验。 两类错误​ 在一定 $\\alpha$ 下，否定 $H_0$ ，如果 $H_0$ 为真，则犯了一个否定真实假设的错误，称之为第一类错误/弃真错误/$\\alpha$ 错误。如果 $H_0$ 是假的，却接受了它，就犯了接受不真实假设的错误，称之为第二类错误/纳伪错误/$\\beta$错误。二者不会同时发生，但是在样本容量相同的情况下，犯第一类错误概率减少，犯第二类错误的概率就会增加。 4.2 样本平均数的假设检验4.2.1 一个样本平均数的假设检验适用于判断一个样本平均数 $\\bar x$ 所属总体平均数$\\mu$ 与已知总体平均数 $\\mu_0$ 是否存在真实差异的检验 （一）总体方差 $\\sigma^2$已知 无论大小样本，样本平均数均服从正态分布，标准化后服从 $u$ 分布 ，用 $u$ 检验 例见 P59 （二）总体方差 $\\sigma^2$未知 大样本，用 $u$ 检验，用 $s^2$ 估计 $\\sigma^2$ ，例见P60 例4.3 小样本，用 $t$ 检验（常用），例见P60 例4.4 4.2.1 两个样本平均数的假设检验两个样本平均数比较的$u$检验是检验两个样本平均数 $\\bar x_1$ $\\bar x_2$ 所属的总体平均数 $\\mu_1$ 和 $\\mu_2$ 是否来自同一个总体 （一）总体方差 $\\sigma_1^2$，$\\sigma_2^2$已知 $u$ 检验 ，需要计算样本平均数差数的标准误 （二）总体方差 $\\sigma_1^2$，$\\sigma_2^2$未知 大样本 用 $u$ 检验 小样本 用 $t$ 检验： 小样本根据实验设计不同，又可分为 成组数据平均数比较的假设检验和成对数据平均数比较的假设检验 1） 成组数据是两个样本的各个变量从各自总体中抽取，没有任何关系，彼此独立，因此无论两个样本容量是否相同，皆为成组；这里也分为三种情况 A : 通过方差同质性检验即$F$ 检验 ；B：未通过$F$ 检验但 样本容量n相同；C : 方差既不同质，样本容量也不同；具体参考$P_{65-66}$； 2）成对数据要求两个样本间配偶成对，每一对样本除了随机地给予不同处理外，其他实验条件应尽量一致。例见$P_{68}$。 4.4 样本方差的同质性检验​ 对样本平均数的假设都是以方差的同质性为前提的，否则假设检验的结论是不正确的，所谓方差的同质性，又名方差齐性（homogeneity of variance），指 各个总体的方差是相同的。因此方差同质性检验就是要从各个样本的方差来推断其总体方差是否相同。 4.4.1 一个样本方差的同质性检验卡方检验 4.4.2 两个样本方差的同质性检验$F$ 分布 4.4.3多个样本方差的同质性检验巴特勒检验法 5. 卡方检验$\\chi^2$ 检验主要有3种用途： 一个样本方差的同质性检验； 适合性检验；. 独立性检验 ​ 适合性检验和独立性检验适用于离散型资料的假设检验，其基本原理是通过$\\chi^2$ 值的大小来检测观测值和理论值之间的偏离程度。前者也叫拟合优度检验，是比较观测值和理论值是否符合（比如遗传学上，检验结果是否符合孟德尔分离定律，自由组合定量）的假设检验，独立性检验室判断两个或两个以上因素之间是否具有关联关系的假设检验，常用列联表进行检验。 6.方差分析​ 方差分析(analysis of variance, ANOVA)，用于对 两个或多个样本平均数进行差异显著性检验。其基本思想是将测量数据的总变异按来源分解为处理（组间）效应，和误差（组内）效应，并作出其数量估计，从而确定试验处理对研究结果影响力的大小。可分为 单因素，二因素，多因素方差分析。基本步骤为总平方法和分解、总自由度分解和$F$ 检验，若$F$ 检验显著，需要多重比较，常用的多重比较方法有 最小显著差数法(LSD)和 最小显著极差法(LSR)，LSR又可细分为新复极差法，Duncan法，也称SSR。和$q$ 检验 6.1 基本原理​ 不同的观测值可能由于处理效应，也可能由于误差效应。方差分析中使用方差来反映测量数据变异性，将测量数据的总变异性分为处理效应和误差效应，即分别计算处理效应的方差和误差效应的方差，在一定显著水平下进行比较，相差不大，则说明处理对指标影响不大；如果较大，则说明处理影响很大。 6.2 数学模型以书中$P_{95}$ 表6-1为例，单因素，$K$个水平，每个水平$n$个重复，共$nk$ 观测值。 其中 $x_{ij}$ 表示第$i$ 个处理的第$j$个观测值，对于任何一个$x_{ij}$ ，都可用线性可加模型进行描述，即： ​ $x_{ij} = \\mu_i + e_{ij}$ ，其中 $\\mu_i$ 为第$i$个处理观测值总体平均数；$ e_{ij}$ 为试验误差，要求$ e_{ij}$ 相互独立，且服从正态分布$N(0，\\sigma^2)$ 对于总体平均数$\\mu$ ，有 $\\mu = \\frac{\\sum_{i=1}^k\\mu_i}{k}$ 令 $\\tau_i$ 为第$i$ 个处理的效应，则 $\\tau_i = \\mu_i - \\mu$ ，则推导出： $x_{ij} = \\mu + \\tau_i + e_{ij}$ 即 单因素试验资料的数学线性模型，对应的 样本估计的线性模型为 $x_{ij} = \\bar x + t_i +e_{ij}$ 6.3 平方和与自由度的分解6.3.1 平方和分解​ 方差 是离均差平方和(sum of square，SS) 除以 自由度的商。所以变异分解就是将总平方和与总自由度分解为各个变异来源的相应部分。任一观测值$x_{ij}$ 与总平均数 $\\bar x$ 之差 可以表示为： $(x_{ij} - \\bar x_{..}) = (x_{ij} - \\bar x_{i.}) + (\\bar x_{j.}-\\bar x_{..})$ = 组内差异 + 组间差异 两边平方，然后所有观测值累加，其中由于 试验误差服从 $\\mu$ = 0 的正态分布，所以有一累加项为0。最后得到： $\\sum_{1}^k\\sum_{1}^n(x_{ij-\\bar x_{..}})^2 = \\sum_{1}^k\\sum_{1}^n(x_{ij-\\bar x_{i.}})^2 + n\\sum_{1}^k(\\bar x_{i.}-\\bar x_{..})^2$ 即 $SS_T = SS_e + SS_t$ 总平方和 = 组内平方和 + 组间平方和 6.3.2 自由度分解​ 分解为处理间自由度，处理内自由度。即总自由度 = 处理间自由度 + 处理内自由度：$df_T = df_t + df_e$ $df_T = nk-1，df_t = k-1，df_e = k(n-1)$ 6.3.3 计算方差$s_t^2 = \\frac{SS_t}{df_t}，s_e^2 = \\frac{SS_e}{df_e}$ 6.3 $F$检验​ 在方差分析中进行$F$检验的目的在于推断处理间的差异是否存在，因此计算时，总是以被检验因素的均方做分子，误差均方做分母，最后结果形成一个方差分析表： 变异来源 $df$ $SS$ $s^2$ $F$ $F_{0.05}$ $F_{0.01}$ 营养土间（组间） 3 15.45 5.15 11.98** 3.24 5.29 营养土内（组内） 16 6.86 0.43 总变异 19 22.31 6.4 多重比较​ F检验只能从总体上说明$k$个处理效应显著，但不代表每两个处理平均数间差异显著，也无法具体说明哪些处理有显著，哪些不显著，要做到这点，需要把多个平均数两两间进行相互比较，统计学上称之为多重比较。常用 最小显著差数法和最小显著极差法 6.4.1 最小显著差数法(LSD)​ 实质是两个平均数相比较的 $t$ 检验法。检验时先计算出达到差异显著的最小差数，记为LSD，然后将所有样本的平均数按从大到小排序，依次计算两两差值，若 大于指定显著水平下的LSD，则显著，反之则反。结果以标记字母法和梯形法展示。缺点：没有考虑到相互比较的平均数依数值大小排列上的秩次，仍存在推断可靠性低，弃真错误概率增加的问题。 6.4.2 最小显著极差法(LSR)​ 在一定显著水平$\\alpha$ 下，根据 极差范围内所包含的处理数据(也称秩次距)M的不同而采用不同的显著差数标准来比较。细分为 新复极差法 和$q$ 检验。在对应的$df_e 和 M$ 下，一个是查 $SSR_\\alpha$ ，一个是查 $q_\\alpha$。详见书$P_{103-105}$。 ​ 其他生物统计学学内容等以后用到再添加吧！暂时完结撒花！","link":"/2020/09/06/Biostatistic-basic/"}],"tags":[{"name":"R","slug":"R","link":"/tags/R/"},{"name":"生统","slug":"生统","link":"/tags/%E7%94%9F%E7%BB%9F/"}],"categories":[]}